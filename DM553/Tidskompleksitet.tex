\chapter{Tidskompleksitet}
Beregnelighedsteori, som er den teori vi har kigget på indtil videre om hvorvidt et sprog er afgørligt eller ej, genkendeligt eller ej, osv. har været et stort emne i 1930'erne til 1950'erne, hvor matematikere forsøgte at finder metoder hvorpå de kunne formalisere matematisk ræsonnement. Dette emne er ikke et der er kigget på meget længere, men det er det næste emne som vi vil kigge på nu, nemlig \textbf{kompleksitetsteori}, som kan reduceres til sprøgsmålet om ``Er $A$ afgørligt med begrænset ressurser?'' Disse ressurser kan være mange ting, tid, hukommelse, etc.

\section{Måling af kompleksitet}%
\label{sec:measuringcomplexity}

Da dette ikke er et delkapitel som er en del af pensum, kommer alle mine noter fra forfatterens Youtube video om delkapitlet: \href{https://www.youtube.com/watch?v=asjAc90L8rE&list=PLidiQIHRzpXIFFbyGrWkqXXVj0BztDcTF&index=12}{12. Time Complexity}, og den lille del Jørgen har i sin video.

Vi starter med at kigge på eksemplet $A = \{a^{n}b^{n} \mid n \ge 0\}$. Vi stiller nu spørgsmålet: \textit{hvor mange skridt er nødvændige for at afgøre $A$}? Svaret på dette kommer naturligvis an på længden af det input vi er givet, og vi er derfor nødt til at give et svar ved en \textit{upper bound}. Det er altså det vi kalder \textit{worst-case}.

\begin{definition}[Køretid]
	Lad $M$ være en deterministisk Turingmaskine som afgører et sprog. \textit{Køretiden} eller \textit{tidskompleksiteten} af $M$ er funktionen $f: \mathbb{N} \rightarrow \mathbb{N}$ hvor $f(n)$ er det maksimum antal af skridt som $m$ tager på et input af længde $n$.
\end{definition}

\begin{definition}[Store $O$]
	$f(n)$ er $O(g(n))$ hvis $f(n) \le cg(n)$ for en konstant $c$ uafhængig af $n$.
\end{definition}

\begin{definition}[Lille $o$]
	$f(n)$ er $o(g(n))$ hvis $f(n) \le \varepsilon g(n)$ for alle $\varepsilon > 0$ og et stort $n$.
\end{definition}

Lad os kigge på et eksempel hvor vi bruger store $O$ notation.

\begin{theorem}
	En 1-bånds deterministisk Turingmaskine $M$ kan afgøre $A$ på input længde $n$, hvor $M$ bruger højest $cn^{2}$ skridt for en konstant $c$.
\end{theorem}

Det vil altså sige at $M$ har køretid $O(n^{2})$.

\begin{proof}
	"M = på input $w$
	\begin{enumerate}
		\item Scan input til at tjekke at det er i den rigtige rækkefølge, altså $w \in a^{*}b^{*}$. \textit{Afvis} hvis ikke.

		\item Løkke indtil alle er krydset af
		      \begin{enumerate}
			      \item Scan båndet, kryds én $a$ og én $b$
			      \item \textit{Afvis} hvis kun $a$ eller $b$ er tilbage
		      \end{enumerate}
		\item \textit{Accepter} hvis alle er krdyset af.''
	\end{enumerate}

	Første punkt tager $O(n)$ tid.
	Næste skridt tager $O(n)$ tid $O(n)$ gange, altså $O(n \times n) = O(n^{2})$. Det vil altså sige at algoritemn tager tid $O(n + n^{2}) = O(n^{2})$.
\end{proof}

Vi kan faktisk lave en algoritme der kører i $O(n \log n)$ tid, og en på 2 bånd der kører i $O(n)$ tid, men det gider vi ikke til at kigge på nu.

Læg dog mærke til at der er forskel på den laveste upper-bound pr model. I beregnlighedsteori er hvilken model vi vælger lige gyldig, hver model er altså ækvivalent i hvilket sprog den genkender/afgører etc. Dette gælder \textbf{ikke} i kompleksitetsteori. Her er det forskelligt fra model til model hvor mange skridtr en maskine tager.

\begin{definition}
	Lad $t: \mathbb{N} \longrightarrow \mathbb{N}$. Vi siger at en Turingmaskine $M$ kører i tid $t(n)$ hvis $M$ altid stopper indenfor $t(n)$ skridt på alle input af længde $n$.
\end{definition}

Det betyder for eksempel, at hvis vi har en maskine der kører på tid $t(n^{2})$, og vi giver den et input på $10$, så er det \textbf{garanteret} at den stopper indenfor 100 skridt.

\begin{definition}
	\begin{align*}
		TIME(t(n)) = \{B \mid & \text{ en deterministisk 1-bånds Turingmaskine }                  \\
		                      & M \text{ afgører } B \text{ og } M \text{ kører i tid } O(t(n))\}
	\end{align*}
\end{definition}

Altså er $TIME(t(n))$ en \textbf{klase af sprog} som kører i tid $O(t(n))$, hvis $t(n) = n^{2}$, så er $TIME(n^{2})$ klassen af sprog der kører i $O(n^{2})$. Det betyder også at der er klasser der er delmængder af andre klasser. For eksempel $TIME(n) \subset TIME(n \log n) \subset TIME(n^{2}) \subset \cdots$.


\section{Klassen P}%
\label{sec:p}

\subsection{Polynomiel Tid}%
\label{subsec:polynomialtime}

Vi ser på polynomielle forskelle i køretid som værende små, og eksponentielle som værende store. Vi gør dette grundet væksten af polynomielle funktioner versus eksponentielle funktioner. Et polynomie som $n^{3}$ og en eksponent som $2^{n}$ har meget forskellige værdier når $n$ bliver større og større, f.eks., hvis $n = 1000$ er $n^{3}$ 1 milliard, hvor $2^{n}$ er langt større end antallet af atomer i universet.

Eksponentielle algoritmer fremkommer ofte i \textbf{brute-force søgninger}, altså hvor vi ``bare leder efter en løsning'' på et problem, fremfor en effektiv løsning. Hvis man har en dybere forståelse af et problem, kan man ofte finde en polynomiel løsning.

\begin{definition}
	To komputeringsmodeller er \textbf{polynomielt relateret} hvis de kan simulere hinanden i polynomiel tid.
\end{definition}

Alle ``reasonable'' (ifølge Sipser) deterministiske modeller er polynomielt relateret:
\begin{itemize}
	\item 1 bånds DTM
	\item Flerbånds DTM
	\item Multi-dimensionelle DTM
	\item Random Access Machines
	\item Cellular Automata
\end{itemize}

\begin{definition}[Klassen $P$]
	$P$ er klassen af sprog som er afgørlige i Polynomiel tid på en deterministisk enkeltbånds Turingmaskine. I andre ord:
	\begin{equation*}
		P = \bigcup_{k} TIME(n^{k})
	\end{equation*}
\end{definition}

Det vil altså sige at klassen $P$ er alle problemer der har tidskompleksitet $n^{k}$ \textbf{eller under}.

$P$ er en vigtig klasse fordi det er en invariant af alle modeller for komputering som er polynomielt ækvivalente til en deterministisk enkeltbånds Turingmaskine, og $P$ svarer nogenlunde til klassen af problemer som man realistisk kan løse på en computer.

Bemærk at vi her kun er interesseret i beslutningsproblemer, altså om hvorvidt strengen $w$ er en del af et sprog.

\subsection{Eksempler på problemer i klassen P}%
\label{subsec:examplesinp}

Når vi beskriver en algoritme der kører i polynomiel tid er der to ting der er vigtige. Først er det vigtigt at der er en polynomiel upper bound, normalvist i store-$O$ notation, på antallet af ``stadier'' som algoritmen bruger når den kører på en input af længde $n$. Så skal vi undersøge de individuelle stadier i beskrivelsen af algoritmen, for at sikre at hvert stadie kan implementeres i polynomiel tid på en rimelig deterministisk model. Når disse to ting er gjort, kan vi konkludere at algoritmen kører i polynomiel tid, fordi vi har demonstreret at den køre i en polynomiel antal af stadier, hvor hver af disse stadier også kan køres i polynomiel tid.

Det første problem vi kigger på omhandler rettede grafer. En rettet graf $G$ indeholder knuder $s$ og $t$. $PATH$ problemet er at bestemme om en rettet vej eksisterer fra $s$ til $t$. Lad
\begin{equation*}
	PATH = \{\text{\texttt{<G><s><t>}} \mid G \text{ er en rettet graf som har en direkte vej fra } s \text{ til } t\}
\end{equation*}

\begin{theorem}
	$PATH \in P$
\end{theorem}

Før vi beskriver en algoritme der løser $PATH$ i polynomiel tid, vil vi vise at en brute-force algoritme ikke er hurtig nok. En brute-force algoritme undersøger alle mulige veje i $G$ og bestemmer hvorvidt en er en rettet vej fra $s$ til $t$. En potentiel vej er en sekvens af knuder i $G$ af længde højest $m$; hvor $m$ er antallet af knuder i $G$. Bemærk at en vej ikke kan have længde større end $m$, da der ville være repetition, hvilket aldrig er nødvendigt. Antallet af sådanne veje er cirka $m^{m}$, hvilket er eksponentielt for antallet af knuder i $G$. Derfor bruger en brute-force algoritme som denne eksponentielt tid.

En måde hvorpå vi så kan gøre dette uden at bruge brute-force er \textit{breadth-first-search} som markerer alle knuder i $G$ som man kan komme til fra $s$ ved rettede veje af længde 1, så længde 2, så længde 3, hele vejen til længde $m$.

\begin{proof}
	En polynomiel tidsalgoritme $M$ for $PATH$ fungerer som følger:

	$M =$ ``På input \texttt{<G><s><t>}, hvor $G$ er en erttet graf med knuder $s$ og $t$:
	\begin{enumerate}
		\item Placer en markering på knude $s$
		\item Løkke følgende indtil der ikke markeres flere knuder:
		      \begin{enumerate}
			      \item Scan alle kanterne af $G$. Hvis en kant $(a,b)$ er fundet ved at gå fra en markeret knude $a$ til en umarkeret knude $b$, så markér $b$.
		      \end{enumerate}
		\item Hvis $t$ er markeret, \textit{accepter}, ellers, \textit{afvis}.
	\end{enumerate}

	Vi analyserer nu algoritmen til at vise at den kører i polynomiel tid. Stadie 1 og 3 eksekveres tydeligvis kun én gang. Stadie 3 kører højest $m$ gange, fordi den højest kan markere $m$ knuder. Dermed er det endelige antal af stadier brugt højest $1 + 1 + m$, hvilket er polynomielt i størrelsen af $G$.
\end{proof}

Vi vil nu kigge på eksemplet af relative primtal. To tal er relative primtal hvis $1$ er det største heltal som ligeligt deler dem begge. For eksempel er $10$ og $21$ relative primtal, selvom ingen af dem er primtal. Dog er $10$ og $22$ ikke relative primtal, da begge er delelige med $2$. Lad $RELPRIME$ være problemet om at teste hvorledes to tal er relative primtal.

\begin{equation*}
	RELPRIME = \{\text{\texttt{<x><y>}} \mid x \text{ og } y \text{ er relative primtal}\}
\end{equation*}

\begin{theorem}
	$RELPRIME \in P$
\end{theorem}

En mulig algoritme til at løse dette problem søger igennem alle mulige divisorer (tal der deler) af begge tal, og accepterer kun hvis ingen af dem er større end 1. Dette er dog eksponentielt. I stedet løser vi problemet med en gammel numerisk procedure, \textbf{Euklids Algoritme}. Den \textbf{største fælles divisor}\footnote{Trods det lyder afsindigt grimt, er det åbenbart det rigtigt navn på dansk: \href{https://denstoredanske.lex.dk/st\%C3\%B8rste_f\%C3\%A6lles_divisor}{Største Fælles Divisor - Den Store Danske}} af naturlige tal $x$ og $y$, skrevet $gcd(x,y)$ er det største heltal som ligeligt deler både $x$ og $y$. For eksempel, $gcd(18,24) = 6$, da $6$ er det største tal der både går op i 18 og 24. Dermed er to tal relative primtal hvis $gcd(x,y) = 1$.

\begin{proof}
	Lad Euklids algoritme $E$ være følgende: \\
	\noindent
	$E = $ ``På input \texttt{<x><y>}, hvor $x$ og $y$ er naturlige tal i binær repræsentation:
	\begin{enumerate}
		\item Løkke indtil $y = 0$:
		      \begin{enumerate}
			      \item Lad $x \leftarrow x \mod y$
			      \item Byt $x$ og $y$
		      \end{enumerate}
		\item Output $x$.''
	\end{enumerate}

	Algoritmen $R$ løser $RELPRIME$, ved brug af $E$.\\
	\noindent
	$R = $ ``På input \texttt{<x><y>}, hvor $x$ og $y$ er naturlige tal i binær repræsentation:
	\begin{enumerate}
		\item Kør $E$ på \texttt{<x><y>}
		\item Hvis resultatet er $1$, så \textit{accepter}, ellers \textit{afvis}.''
	\end{enumerate}

	Det er her klart at se at hvis $E$  kører polynomielt, så gør $R$ også. Hver udførelse af stadie $2$  i $E$ skærer værdien i halv. Efter stadie 2 er udført er $x < y$ givet hvordan modulus funktionen fungerer. Efter stadie $3$ er $x > y$ fordi de er byttet. Dermed når stadie 3 er udført efterfølgende, $x > y$. Hvis $x/2 \ge y$, så $x \mod y < y < x / 2$ og $x$ bliver skåret med mindst halvdelen. Hvis $x / 2 < y$ så $x \mod y = x - y < x / 2$ og $x$ skæres med mindst halvdelen.

	Værdierne af $x$ og $y$ bliver byttet hver gang stadie $3$ udføres, så hver af de originale værdier af $x$ og $y$ reduceres til mindst halvdelen hver anden gang igennem løkken. Dermed er maksimum antallet af gangene stadie 2 og 3 udføres den mindste af $2 \log_{2} x$ og $2 \log_{2} y$. Disse logaritme er proportionelle til længden af repræsentationerne, hvilker giver antallet af stadier der uføres til $O(n)$. Dermed er den endelige køretid polynomiel.
\end{proof}

Vores sidste eksempel viser at hvert CFL er afgørligt i polynomiel tid.

\begin{theorem}
	Hvert kontekst-frit sprog er medlem af $P$.
\end{theorem}

Vi har tidligere bevist at alle kontekstfrie sprog er afgørlige, men algoritmen vi brugte der er ikke polynomiel\footnote{Se Sipser pp. 290 ed. 3 for flere detaljer} med i deterministisk Turingmaskine, men polynomiel i en nondetermistisk Turingmaskine (ved bare at prøve hver vej, og tjekke om den vej genererer $w$). For at få en deterministisk polynomiel algoritme bruger vi dynamisk programmering.
%% MANGLER
\begin{proof}

\end{proof}

\section{Klassen NP}%
\label{sec:np}

Der er mange problemer hvor vi endnu ikke har fundet en måde at undgå at bruge brute-force løsninger til problemer på, resulterende i eksponentielle algoritmer.

Kompleksiteten af mange problemer hænger sammen - en polynomiel tids algoritme for et problem kan bruges til at løse en hel klasse af problemer. For at forstå dette bruger vi et eksempel.

En \textit{Hamiltonian vej} i en rettet graf $G$ er en rettet vej som går igennem hver knude præcis én gang. Lad
\begin{equation*}
	HAMPATH = \{\text{\texttt{<G><s><t>}} \mid G \text{ er en rettet graf med en Hamiltonien vej fra } s \text{ til } t\}
\end{equation*}

Vi kan sagtens finde en algoritme der kører i eksponentiel tid ved at ændre lidt i brute-force algoritmen fra $PATH$. Ingen ved endnu om $HAMPATH$ er løselig i polynomiel tid. $HAMPATH$ problemet har en funktion (feature) kaldet \textit{polynomiel verificerbarhed} som er vigtig for at forstå dens kompleksitet. Selvom vi ikke kender en polynomiel måde at bestemme om en graf indeholder en Hamiltionen vej, hvis en sådan vej findes, kan vi meget hurtigt se om vejen er korrekt eller ej. I andre ord kan vi nemt \textit{verficiere} en Hamiltonian vej, og dette er muligvis langt nemmere end at bestemme dens eksistens.

Et andet polynomielt verificérbart problem er sammensathed\footnote{Compositeness på engelsk.}. Husk at et naturligt tal er sammensat hvis det er produktet af to heltal større end 1,
\begin{equation*}
	SAMMENSATTE = \{x \mid x = pq, \text{ for heltal } p, q > 1\}
\end{equation*}

Vi kan nemt verificere at et tal er sammensat. Alt der er nødvendigt for dette er en divisor for tallet. For nyligt blev en polynomiel algoritme for at teste hvorledes et tal er primtal eller sammensat fundet. Nogle problemer er muligvis ikke polynomielt verificérbare. For eksempel komplementet af $HAMPATH$ problemet, $\overline{HAMPATH}$.

\begin{definition}
	En \textbf{verifikator} for et sprog $A$ er en algoritme, $V$,hvor
	\begin{equation*}
		A = \{w \mid V \text{ accepterer \texttt{<w><c>} for en streng }c \}
	\end{equation*}

	Vi måler tiden af en verifikator kun i form af længden af $w$, så en \textit{polynomiel tids verifikator} kører i polynomiel tid på længden af $w$. Et sprog $A$ er \textit{polynomielt verificérbart} hvis det har en polynomiel tids verifikator.
\end{definition}

En verifikator bruger et \textit{certifikat} eller et \textit{bevis} af medlemskab i $A$ til at verificere at en streng $w$ er et medlem af $A$. Dette repræsenteres af $c$ i definitionen.

For $HAMPATH$ problemet, er certifikatet af en streng \texttt{<g><s><t>} $\in HAMPATH$ er, simpelt, en Hamiltionion vej fra $s$ til $t$. For $SAMMENSATTE$ problemet er certifikatet bare en af dets divisorer. I begge tilfælde kan verifikatoren tjekke i polynomiel tid at inputtet er i sproget når den er givet certifikatet.

\begin{definition}
	\textbf{NP} er klassen af sprog som har polynomielle tidsverifikatorer.
\end{definition}

Både $HAMPATH$ og $SAMMENSATTE$ er medlemmer af $NP$. $NP$ kommer simpelt fra \textbf{nondeterministisk polynomiel tid}; og kommer fra en alternativ karakterisering ved at bruge nondeterministiske polynomielttids Turingmaskiner. Problemer i NP kaldes nogle gange $NP$-problemer.

Følgende er en Nondeterministk Turingmaskine som afgører $HAMPATH$ i nondeterministisk polynomiel tid.\\\\
\noindent
$N_{1} = $ ``På input \texttt{<G><s><t>}, hvor $G$ er en rettet graf med knuder $s$ og $t$:
\begin{enumerate}
	\item Skriv en liste af $m$ tal, $p_{1}, \ldots, p_{m}$ hvor $m$ er antallet af knuder i $G$. Hvert tal i listen af nondeterministisk valgt til at være mellem $1$ og $m$.
	\item Tjek for repetitioner i listen, hvis nogen findes, \textit{afvis}.
	\item Tjek om $s = p_{1}$ og $t = p_{m}$. Hvis nogen fejler, \textit{afvis}.
	\item For hvert $i$ mellem $1$ og $m-1$, tjek om $(p_{i}, p_{i+1})$ er en kant af $G$. Hvis ikke, \textit{afvis}, ellers \textit{accepter}.''
\end{enumerate}

Hvert stadie her kører i polynomiel tid, og derfor kører algoritmen altså i nondeterministisk polynomiel tid.

\begin{theorem}
	Et sprog er i NP $\iff$ det er afgjort af en nondeterministisk polynomiel tids Turingmaskine.
\end{theorem}

Vi viser først hvordan man konverterer en polynomieltids verifikator til en ækvivalent polynomieltids nondeterministisk Turingmaskine, og så omvendt. Den nondeterministiske Turingmaskine simulerer verifikatoren ved at gætte på certifikatet. Verifikatoren simulerer den Nondeterministiske Turingmaskine ved at bruge den accepterende gren som certifikatet.

\begin{proof}
	For den fremadgående vej af teoremet, lad $A \in NP$ og vis at $A$ er afgjort af en polynomieltids nondeterministisk Turingmaskine $N$. Lad $V$ være polynomieltidsverifikatoren for $A$ som eksisterer fra definition af $NP$. Antag at $V$ er en Turingmaskine som kører i $n^{k}$ tid, og konstruér $N$ som følger:

	$N = $ ``På input $w$ af længde $n$:
	\begin{enumerate}
		\item Nondeterministk vælg streng $c$ af længde højest $n^{k}$
		\item Kør $V$ på input \texttt{<w><c>}
		\item Hvis $V$ accepterer, så \textit{accepter}, ellers \textit{afvis}.''
	\end{enumerate}

	For at bevise den omvendte vej, antag at $A$ er afgjort af en polynomieltids nondeterministisk Turingmaskine $N$ og konstruér en Polynomieltids Verifikator $V$ som følger:

	$V = $ ``På input \texttt{<w><c>}, hvor $w$ og $c$ er strenge:
	\begin{enumerate}
		\item Simulér $N$ på input $w$ og behandl hvert symbol i $c$ som en beskrivelse af det nondeterministiske valg der skal foretages på hvert trin.
		\item Hvis denne gren af $N'$s komputering accepterer, så \textit{accepter}, ellers \textit{afvis}.''
	\end{enumerate}


\end{proof}

Vi definerer den nodneterministiske tidskompleksitetsklasse $NTIME(t(n))$ som analog til den deterministiske tidskompleksitetsklasse $TIME(t(n))$.

\begin{definition}
	\begin{align*}
		NTIME(t(n)) = \{ L \mid & L \text{ er et sprog afgjort af en } O(t(n)) \text{tids} \\
		                        & \text{nondeterministisk Turingmaskine}\}
	\end{align*}
\end{definition}


\begin{corollary}
	\begin{equation*}
		NP = \bigcup_{k} NTIME(n^{k})
	\end{equation*}
\end{corollary}


\subsection{Eksempler af problemer i NP}%
\label{subsec:NPexamples}

En \textbf{klikke} i en urettet graf er en subgraf, hvori hver to knuder er sammensat af en kandt. En $k-klikke$ er en klikke som indeholder $k$ knuder.

Klikkeproblemet omhandler at finde ud af om en graf indeholder en klikke af en specifik størrelse, lad
\begin{equation*}
	KLIKKE = \{\text{\texttt{<G><k>}} \mid G \text{ er en urettet graf med en } k-\text{klikke}\}
\end{equation*}

\begin{theorem}
	$KLIKKE$ er i $NP$.
\end{theorem}

\begin{proof}
	Følgende er en verifikator $V$ for $KLIKKE$.\\\\
	\noindent
	$V = $ `` På input \texttt{<<G><k>><c>}:
	\begin{enumerate}
		\item Tjek om $c$ er en subgraf med $k$ knuder i $G$.
		\item Tjek om $G$ indeholder alle knuder der forbinder knuder i $c$.
		\item Hvis begge består, \textit{accepter}, ellers \textit{afvis}.''
	\end{enumerate}
\end{proof}

Man kan også bevise det ved at lave en nondeterministisk polynomiel algoritme:

\begin{proof}
	$N = $ ``På input \texttt{<G><k>} hvor $G$ er en graf:
	\begin{enumerate}
		\item Nondeterministisk vælg en delmængde $c$ af $k$ knuder af $G$.
		\item Tjek om $G$ indeholder alle kanter der forbinder knuder i $c$.
		\item Hvis ja, \textit{accepter}, ellers \textit{afvis}.''
	\end{enumerate}
\end{proof}

\subsection{P versus NP spørgsmålet}%
\label{subsec:pvsnp}

Vi opsummerer $P$ og $NP$ som følger:
\begin{align*}
	\text{P}  & = \text{ klassen af sprog hvor medlemskabet kan blive \textit{afgjort} hurtigt.}     \\
	\text{NP} & = \text{ klassen af sprog hvor medlemskabet kan blive \textit{verificeret} hurtigt.}
\end{align*}

Vi kan ikke bevise eksistensen af et enkelt sprog i $NP$ som ikke er i $P$, så det er muligt at $P = NP$. Dette er en af de største uløste problemer i datalogi, og moderne matematik. Hvis disse klasser var lige, ville ethver polynomielt verificérbart problem være polynomielt afgørligt. De fleste forskere tror ikke at de to klasser er ens, fordi folk har brugt rigtig meget indsats  på at finde polynomieltidsalgoritme for nogle af problemer i $NP$ uden succes. Forskere har også prøvbet at bevise at klasserne er ulige men uden succes. For at bevise uligheden ville det kræve at man skulle vise at der ikke findes en hurtig algoritme til at erstatte brute-forcing.

Den bedste derministiske metode vi kender til at afgøre sprog i $NP$ bruger eksponentiel tid, i andre ord kan vi bevise at
\begin{equation*}
	NP \subseteq EXPTIME = \bigcup_{k} TIME (2^{n^{k}})
\end{equation*}
Men vi ved ikke om $NP$ er en del af en mindre, deterministisk kompleksitetsklasse.

\section{NP-Komplet}%
\label{sec:npcompleteness}

% TODO: Herfra begynder jeg at bruge \(\langle \rangle\) fremfor \texttt{< >}. Jeg skal have gjort det i resten også.

\textbf{NP-Komplette} problemer er problemer hvis individuelle kompleksitet er relateret til en hel klasses kompleksitet. Altså, hvis der findes en polynomiel algoritme til en af disse problemer, vil alle problemer i $NP$ være polynomielt løslige.

Det første $NP$-fuldstændige problem vi kigger på er \textit{satisfiability problemet}.

En boolsk formel er satisfiable hvis en tildeling af 0'er og 1'er til variablerne gør at formlen evaluerer til 1. Eksempelvis er følgende formel satisfiable når $x = 0, y = 1, z = 0$:
\begin{equation*}
	\phi = (\overline{x} \land y) \lor (x \land \overline{z})
\end{equation*}

Satisfiability problemet er at teste hvorledes en boolsk formel er satisfiable:
\begin{equation*}
	SAT = \{ \langle \phi \rangle \mid \phi \text{ er en satisfiable boolsk formel}\}
\end{equation*}

Følgende teorem siger at kompleksitetsklassen af SAT problemet er ens til kompleksiteten af alle problemer i $NP$.

\begin{theorem}
	$SAT \in P \iff P = NP$
\end{theorem}

\subsection{Polynomieltids Reducérbarhed}%
\label{subsec:polynomialreducibility}

Her viser vi hvordan et problem $A$ kan reduceres til et problem $B$, der så kan bruges til at løse $A$. Når problem $A$ er effektivt reducérbart til problem $B$, kan en effektiv løsning til $B$ bruges til at løse $A$ effektivt.

\begin{definition}
	En funktion $f : \Sigma^{*} \longrightarrow \Sigma^{*}$ er en polynomieltids beregnelig funktion hvis en polynomieltids Turingmaskine $M$ eksisterer som stopper med $f(w)$ på sit bånd, når den er startet på et input $w$.
\end{definition}

\begin{definition}
	Sprog $A$ er polynomielttids reducerbart\footnote{Mapping reducible på engelsk} til sprog $B$, skrevet $A \leq_{P} B$, hvis en polynomieltids beregnlig funktion $f : \Sigma^{*} \longrightarrow \Sigma^{*}$ eksisterer, hvor for hvert $w$,
	\begin{equation*}
		w \in A \iff f(w) \in B
	\end{equation*}
	Funktionen $f$ kaldes polynomielt tids reduktionen af $A$ til $B$.
\end{definition}

Hvis et sprog er polynomielt tids reducérbart til et sprog som allerede er kendt til at have en polynomiel tids løsning, får vi en polynomiel tids løsning til det originale sprog, pr det følgende teorem:

\begin{theorem}
	Hvis $A \le_{P} B$ og $B \in P$, så $A \in P$
\end{theorem}

\begin{proof}
	Lad $M$ være polynomiel tids algoritmen der afgører $B$ og $f$ være polynomiel tids reduktionen fra $A$ til $B$. Vi beskriver en polynomieltids algoritme $N$ som afgører $A$ som følger:\\
	\noindent
	$N = $ ``På input $w$:
	\begin{enumerate}
		\item Beregn $f(w)$.
		\item Kør $M$ på input $f(w)$ og output hvadend $M$ outputter.''
	\end{enumerate}

	Vi har $w \in A$ når $f(w) \in B$ fordi $f$ er en reduktion fra $A$ til $B$. Dermed accepterer $M$ $f(w)$ når $w \in A$. $N$ kører i polynomiel tid fordi hver af dens to stadier kører i polynomiel tid. Stadie 2 kører i polynomiel tid fordi kompositionen af to polynomier er polynomiel.
\end{proof}

Husk $3-SAT$ problemet fra DM551,
\begin{equation*}
	3SAT = \{ \langle \phi \rangle \mid \phi \text{ er en satisfiable }3cnf\text{-formel}\}
\end{equation*}

Hvor $3cnf$ blot betyder at hver clause har 3 literals i sig, og har formen $\phi = (x \lor x \lor x) \land (x \lor x \lor x) \land \cdots$.

Det følgende teorem præsenterer en polynomieltidsreduktion fra $3SAT$ til $KLIKKE$ problemet.

\begin{theorem}
	$3SAT$ er polynomielt tidsreducérbart til KLIKKE.
\end{theorem}

Reduktionen $f$ konverterer formler til grafer. I de konstruerede grafer, svarer klikker af en specifik størrelse til satisfying assignment af formlen.

Vi giver en hurtig

\begin{proof}
	Lad $\phi$ være en formel med $k$ klausuler såsom:
	\begin{equation*}
		\phi = (a_{1} \lor b_{1} \lor c_{1}) \land (a_{2} \lor b_{2} \lor c_{2}) \land \cdots \land (a_{k} \lor b_{k} \land c_{k})
	\end{equation*}
	Reduktionen $f$ genererer strengen \(\langle G,k \rangle \) hvor $G$ er en urettet graf defineret som følger.
	Knuderne i $G$ organiseres i $k$ grupper af tre knuder, hver kaldet tripler, $t_{1}, \ldots, t_{k}$. Hver triple svarer til en af de klausuler i $\phi$, og hver knude i en triple svarer til en literal i den associeret klausul. Vi giver dermed også hver knude i $G$ værdien for hver literal i $\phi$.

	Kanterne i $G$ forbinder alle undtagen to typer af par af knuder i $G$. Ingen kant mellem to knuder er den samme triple, og ingen kant findes mellem to knuder med modstridige labels, såsom $x_{2}$ og $\overline{x_{2}}$.

	Vi viser nu hvorfor dette virker. Vi viser at $\phi$ er satisfiable $\iff$ $G$ har en $k-$klikke.

	Antag at $\phi$   har en satisfying assignment, det betyder at der er mindst én literal som er sand i hver klausul. I hver triple af $G$ vælger vi en knude tilsvande til en sand literal i den satisfying assignment. Hvis der er mere end én sand literal, vælger vi bare en af dem arbitrært. De knuder vi lige har valgt former en $k-$klikke. Antallaet af knuder valgt er $k$, da vi vælger én for hver af de $k$ tripler. Hvert par af valgte knuder er forbundet af en kandt.

	Antag at $G$ har en $k-$klikke. Intet par af klikken knuder er i den samme triple, fordi knuderne i den samme triple ikke er forbundet af kanter. Derfor indeholder hver af de $k$ tripler præcis en af de $k$ klikkes knuder. Vi tilegner sandhedsværdier til variablerne af $\phi$ så hver literal

	%% MANGLER:
	%% https://www.youtube.com/watch?v=iZPzBHGDsWI
\end{proof}

Jørgen kommer også med følgende teorem, samt beviset til denne:
\begin{theorem}
	SAT er reducerbart i polynomiel tid til 3-SAT.
\end{theorem}

\begin{proof}
	I et 3-SAT problem har vi klausuler af 3 literals. Ved en almen satisfiability klausul, kan den være af alle mulige størrelser. Vi kigger på 3 cases, og beskriver hvordan de ``konverteres'' til 3-SAT, hvor $|C| =$ størrelsen på klausulen.
	\begin{itemize}
		\item $|C| \ge 4$: En klausul $C_{i} = (\lambda_{1} \lor \lambda_{2} \lor \cdots \lor \lambda_{k})$. Vi introducerer nye variabler $y_{1}, y_{2}, \ldots, y_{k-3}$ kun til klausulen $C_{i}$. Vi erstatter så $C_{i}$ med følgende klausuler:
		      \begin{equation*}
			      X_{i} = (\lambda_{1} \lor \lambda_{2} \lor y_{1}) \land (\overline{y_{1}} \lor \lambda_{3} \lor y_{2}) \land (\overline{y_{2}} \lor \lambda_{4} \lor y_{3}) \land \cdots \land (\overline{y_{k-4}} \lor \lambda_{k-2} \lor y_{k-3}) \land (\overline{y_{k-3}} \lor \lambda_{k-1} \lor \lambda_{k})
		      \end{equation*}
		      %% MANGLER FORKLARING PÅ HVORFOR DEN ER SAND


		\item $|C| = 2$: Simpelt: $(\lambda_{1} \lor \lambda_{2}) \rightarrow (\lambda_{1} \lor \lambda_{2} \lor z) \land (\lambda_{1} \lor \lambda_{2} \lor \overline{z})$
		\item $|C| = 1$: Simpelt: $(\lambda) \rightarrow (\lambda \lor x \lor y) \land (\lambda \lor x \lor \overline{y}) \land (\lambda \lor \overline{x} \lor y) \land (\lambda \lor \overline{x} \lor \overline{y})$
	\end{itemize}
\end{proof}


\subsection{Definitionen af NP-Komplethed}%
\label{subsec:definitionofnpcompleteness}

\begin{definition}[NP-Komplethed]
	\label{def:npcomplete}
	Et sprog $B$ er \textbf{NP-Komplet} hvis det opfylder følgende to betingelser:
	\begin{enumerate}
		\item $B \in NP$
		\item Hvert $A$ i $NP$ er reducerbart i polynomiel tid til $B$.
	\end{enumerate}
\end{definition}

Ud fra denne definition kan vi også se hvordan følgende vigtige teorem fremkommer.
\begin{theorem}
	Hvis $B$ er $NP-$komplet og $B \in P$, så er $P = NP$.
\end{theorem}

\begin{proof}
	Dette følger fra definitionen af polynomiel tids reducérbarhed.
\end{proof}

\begin{theorem}
	Hvis $B$ er $NP$-komplet og $B \le_{P} C$ for $C$ i $NP$, så er $C$ $NP$-komplet.
\end{theorem}

\begin{proof}
	Vi ved allerede at $C$ i er $NP$, så vi skal vise at hvert $A$ i $NP$ er reducerbart i polynomiel tid til $C$. Fordi $B$ er $NP$-komplet, er hvert sprog i $NP$ reducerbart i polynomiel tid til $C$. Dette gælder fordi når $B \le_{P} C$ så $A \le_{P} B \le_{P} C$ da to polynomier lagt sammen også giver et polynomie betyder dette at $A \leq_{P} C$, og dermed er $C$ også NP-komplet.
\end{proof}

\subsection{Flere problemer og Cormen}%
\label{subsec:7.5andcormen}

Resten af dette kapitel kommer fra en blanding af delkapitel 7.5 i Sipser, og Cormen delkapitel 34.5.

Et \textit{vertex cover} af grafen $G$ er en delmængde af knuderne hvor hver kant af $G$ rører en af disse knuder. $Vertex-Cover$ problemet stiller spørgsmålet om der findes et vertex cover af en specifik størrelse:
\begin{equation*}
\text{VERTEX-COVER} = \{ \langle G, k \rangle \mid G \text{ er en urettet graf som har en } k-\text{knude vertex cover}\}
\end{equation*}

\begin{theorem}
	$3 \text{-SAT} \le_P \text{VERTEX-COVER}$
\end{theorem}

Det er nok at vise at $3-\text{SAT} \le_{P} \text{CLIQUE} \le_{P} \text{Independent Set} \le_{P} \text{Vertex-Cover}$, som vi allerede har gjort i Teoremer \textbf{MANGLER} %% MANGLER.
Men nu vil vi gøre det eksplicit.

Givet en instans $f = C_{1} \land C_{2} \land \cdots \land C_{m}$  af 3$\text{-SAT}$ med variablerne $x_{1}, x_{2}, \ldots, x_{n}$. Lad $k = n + 2m$ og konstruér en graf $G = G(f)$ med $2n+3m$ knuder (husk her at $m$ er antallet af klausuler og $n$ er antallet af variable.)
Hver variabel $x_{i}$ repræsenteres af to knuder sat sammen af en kant. Dette kan ses i Figur~\ref{fig:variablepairvc}.
\begin{figure}[ht]
\begin{center}
\begin{tikzpicture}[auto, node distance=3cm, every loop/.style={},
                    thick,main node/.style={circle,draw,font=\sffamily\Large\bfseries}]
		\node[state] (q1) {$v_{i}$};
		\node[state, right=of q1] (q2) {$\overline{v_{i}}$};

		\path[every node/.style={font=\sffamily\small}]
		(q1) edge node {} (q2);
\end{tikzpicture}
\end{center}
  \caption{\label{fig:variablepairvc} Et variabel par i 3-SAT $\le_{P}$ VC.}
\end{figure}

Hver klausul $c_{j}$ repræsenteres af 3 knuder sammensat via kanter som ses i Figur~\ref{fig:clause3sattovc}.
\begin{figure}[ht]

\begin{center}
\begin{tikzpicture}
		\node[state] (q1) {};
		\node[state, right=of q1] (q2) {$z_{j}$};
		\node[state, right=of q2] (q3) {};

		\path[-]
		(q1) edge node {} (q2)
		(q2) edge node {} (q3)
        (q3) edge[bend left] node {} (q1);
\end{tikzpicture}
\end{center}
  \caption{\label{fig:clause3sattovc} En klausul i 3-SAT $\le_{P}$ VC.}
\end{figure}
I Figur~\ref{fig:3sat-to-clique} ses et eksempel på en konversation af en 3-SAT klausul $C_{1} = (x_{1} \lor \overline{x_{3}} \lor x_{5})$ til vertex-cover problemet.
\begin{figure}[ht]
\begin{center}
  \begin{tikzpicture}[node distance=1.0cm]
    \node[state] (1) {};
    \node[state, below=of 1] (2) {$z_{1}$};
    \node[state, below=of 2] (3) {};


    \node[state, above right=0.4cm and 1cm of 2] (v3) {$v_{3}$};
    \node[state, below=of v3] (nv3) {$\overline{v_{3}}$};

    \node[state, above=of v3] (nv1) {$\overline{v_{1}}$};
    \node[state, above=of nv1] (v1) {$v_{1}$};

    \node[state, below=of nv3] (v5) {$v_{5}$};
    \node[state, below=of v5] (nv5) {$\overline{v_{5}}$};


    \path[-]
    (1) edge node {} (2)
        edge node {} (v1)
    (2) edge node {} (3)
        edge node {} (nv3)
    (3) edge[bend left] node {} (1)
        edge node {} (v5)

    (v1) edge node {} (nv1)
    (v3) edge node {} (nv3)
    (v5) edge node {} (nv5);
  \end{tikzpicture}
\end{center}
  \caption{\label{fig:3sat-to-clique} En konversation fra 3-SAT klausulen $(x_{1} \lor \overline{x_3} \lor x_{5})$ til Vertex-Cover problemet.}
\end{figure}



\begin{claim}
$G(f)$ har et Vertex-Cover  af størrelse $n+2m$ $\iff$ $f$ er satisfiable.
\end{claim}

Vi kan relativt nemt se det her. Vi ved at hvert vertex cover har \textit{mindst} størrelse $n+2m$, da der er 2 per klausul trekant (Figur~\ref{fig:clause3sattovc}) og 1 per variabel kant (Figur~\ref{fig:variablepairvc}.) Grunden til at det er 2 per klausul trekant, er da man skal bruge mindst 2 knuder for at finde et vertex cover i trekanten.

\begin{proof}[$f$ er satisfiable $\Rightarrow G(f)$ har et VC  af størrelse $n+2m$]
  Antag at $f$ er satisfied af en truth assignment $t : \{x_{1} \ldots x_{n}\} \rightarrow \{T, F\}^{n}$. Vi konstruerer $U \le V(G)$ ved at tilføje $v_{i}$ til $U$ hvis $t(x_{i}) = T$ og tilføje $\overline{v_{i}}$ til $U$ hvis $t(x_{i}) = F\;\;(t(\overline{x_i}) = T)$. Nu ``cover'' $U$ alle kanter $v_{i} - \overline{v_i}\;\; i \in [n]$

  For hver klausultrekant $Z_{j}$ er der mindst en af kanterne mellem variablerne og klausultrekanten, hvilket betyder at den er covered af $U$, da $C_{j}$ er satisfiable af $t$. Nu er $U$ et vertex cover og $|U| = n +2m$
\end{proof}

\begin{proof}[$G(f)$ har et VC af størrelse $n+2m$ \(\Rightarrow f\)  er satisfiable]
Antag at $G$ har et vertex cover $X$ hvor $|X| = n+2m$, så er $|X \cap \{v_{i}, \overline{v_{i}}\} = 1$ for $i \in [n]$ og $X$ har præcis 2 knuder (vertices) fra $Z_{j}$ for $j \in [m]$. Lad $\phi(x_{i}) = T \iff v_{i} \in X \; i \in [n]$. Så er $\phi$ en satisfying truth assignment, altså har hver klausul $c_{j}$ en sand literal.
\end{proof}


Vi kigger nu på problemet ``subset-sum''. Subset-sum har som input $\langle S, t \rangle$ hvor $S$  er en mængde af ikke-negative heltal og $t \ge 0$ er et heltal. Problemet stiller så spørgsmålet: Eksisterer der en mængde $S' \subseteq S$ således at $\sum_{x \in S'}x = t$?

\begin{theorem}
\textit{Subset-sum} er $NP$-komplet.
\end{theorem}

\begin{proof}
.
  \begin{enumerate}
    \item Subset-sum $\in NP$: Certifikatet er en mængde $S' \subseteq S$ hvor $\sum_{x \in S'}x= t$.
          \item Vi viser at $3-SAT \le_{P}$ subset-sum.
  \end{enumerate}
  Lad $f = C_{1} \land C_{2} \land \cdots \land C_{m}$ være en 3-sat instans med variablerne $x_{1}, x_{2}, \ldots, x_{n}$. Vi konstruerer en instans $\langle S, t\rangle$ af subset-sum således at: $f$ er afgørlig $\iff$ $\langle S,t \rangle \in $ subset-sum ($\exists S' \subseteq S : \sum_{x \in S'}x=t$)

  Vi kigger på tal i base 10, og lader $t = 11 \cdots 144 \cdots 4$ hvor 1-delen af $n$ og 4-delen er $m$. Vi ser på denne streng som et tal i base 10. Det vil altså sige at der er lige så mange $1$'er som der er variabler, og der er lige så manger 4'er som der er klausuler. Hver variabel $x_{i}$ i $f$ repræsenteres af $v_{i}$\footnote{Ikke en knude!} med:
  \begin{align*}
&x_{i}\;\;\;\;\;\;\;\;\;\;\;\;C_{j}\\
v_{i} = 0 \cdots 0&10 \cdots 0 \cdots 1 \cdots 0 \;\; \text{ 1 i position }j \text{ hvis } x_{i} \text{ er en literal af } C_{j}
  \end{align*}
  \begin{align*}
&x_{i}\;\;\;\;\;\;\;\;\;\;\;\;C_{j}\\
v_{i}' = 0 \cdots 0&10 \cdots 0 \cdots 1 \cdots 0 \;\; \text{ 1 i position }j' \iff \overline{x_{i}} \text{ er en literal af } C_{j}'
  \end{align*}
  Der er kun ét 1-tal i start-delen, da $v_{i}$ og $v_{i}'$ repræsenterer en variabel $x_{i}$, men der kan være flere 1'ere i den anden del, da denne variabel kan være del af flere klausuler. I den anden formel er det alle klausuler hvor $\overline{x_{i}}$ er tilstede.

  Hver klausul $C_{j}$ repræsenteres af $S_{j}, S_{j}'$, hvor
  \begin{align*}
    &{\color{red}C_{j}}\\
 S_{j} = {00 \cdots 0 } {\color{red}0 \cdots 0}&{\color{red}10 \cdots 0}
  \end{align*}
  \begin{align*}
    &{\color{red}C_{j}}\\
 S_{j}' = {00 \cdots 0 } {\color{red}0 \cdots 0}&{\color{red}20 \cdots 0}
  \end{align*}

  Idéen her er at vi gerne vil have der til at stå 4, så det kan ligne $t$. Jørgen har dette på sine slides. Jeg gider ikke til at lave selve tabellen lige nu.
\end{proof}

\begin{claim}
$f$ er satisfiable $\iff$ $\langle S,t\rangle \in $  subset-sum
\end{claim}

\begin{proof}[\(\Rightarrow\)]
  For $i \in [n]$ : hvis $x_{i} = T$, tilføj $v_{i}$ til $S'$, ellers tilføj $v_{i}'$ til $S'$. For $j \in [n]$ :
  \begin{itemize}
    \item Hvis $C_{j}$ har 1 sand literal, tilføj $S_{j}, S_{j}'$ til $S'$
    \item Hvis $C_{j}$ har 2 sande literals, tilføj $S_{j}'$ til $S'$.
    \item Hvis $C_{j}$ har 3 sande literals, tilføj $S_{j}$ til $S'$
  \end{itemize}
\end{proof}

\begin{proof}[\(\Leftarrow\)]
Antag at $S' \subseteq S$ satisfier $\sum_{x \in S'}x = t$, så sæt $x_{i} \leftarrow T \text{ hvis } v_{i} \in S'$ og $x_{i} \leftarrow T \text{ hvis } v_{i}' \in S'$
\end{proof}

Vi går nu videre til hamiltonsk cyklus (hamiltonian cycle.) En Hamiltonsk cyklus er en cyklus $C$ på en graf $G$ hvor $V(C) = V$, altså en cyklus der går igennem hver eneste knude én gang. Den er anderledes fra en hamiltonsk path, idet at den starter også slutter på samme knude.

\begin{theorem}
Hamiltonsk Cyklus er NP-komplet.
\end{theorem}

\begin{proof}
  Hamiltonsk cyklus er i $NP$: Certifikatet er en permutation $v_{1}, v_{2}, \ldots, v_{n}$ således at $v_{i}, v_{i+1} \in E$ for $i = 1, 2, \ldots n-1$ og $v_{1}v_{n} \in E$

  Problemet er NP-komplet da Vertex-cover $\le_{P}$ hamiltonsk cyklus. Til at bevise dette bruger vi en sub-graf, som man kalder en \textit{gadget}:
  \begin{center}
  \begin{tikzpicture}[node distance=1.5cm]

	\node[state] (1) {};
	\node[state, below=of 1]  (2) {};
	\node[state, below=of 2]  (3) {};
	\node[state, below=of 3]  (4) {};
	\node[state, below=of 4]  (5) {};
	\node[state, below=of 5]  (6) {};

	\node[state, right=of 1] (11) {};
	\node[state, below=of 11] (12) {};
	\node[state, below=of 12] (13) {};
	\node[state, below=of 13] (14) {};
	\node[state, below=of 14] (15) {};
	\node[state, below=of 15] (16) {};
	\node[left=of 1] (01) {};
	\node[left=of 6] (06) {};
	\node[right=of 11] (21) {};
	\node[right=of 16] (26) {};

	\path[-]
	(1) edge node {} (13)
		edge node {} (2)
	(2) edge node {} (3)
	(3) edge node {} (4)
		edge node {} (11)
	(4) edge node {} (16)
    	edge node {} (5)
	(5) edge node {}(6)
	(6) edge node {}(14)
	(11) edge node {}(12)
    (12) edge node {}(13)
	(13) edge node {}(14)
	(14) edge node {}(15)
	(15) edge node {} (16)
	(01) edge node {} (1)
	(06) edge node {} (6)
	(21) edge node {} (11)
	(26) edge node {} (16);
  \end{tikzpicture}
  \end{center}

  Der er to måder for en cyklus at besøge alle knuderne på her. Først kan den gøre sådan:
  \begin{center}
  \begin{tikzpicture}[node distance=1.5cm]
	\node[state] (1) {};
	\node[state, below=of 1]  (2) {};
	\node[state, below=of 2]  (3) {};
	\node[state, below=of 3]  (4) {};
	\node[state, below=of 4]  (5) {};
	\node[state, below=of 5]  (6) {};

	\node[state, right=of 1] (11) {};
	\node[state, below=of 11] (12) {};
	\node[state, below=of 12] (13) {};
	\node[state, below=of 13] (14) {};
	\node[state, below=of 14] (15) {};
	\node[state, below=of 15] (16) {};
	\node[left=of 1] (01) {};
	\node[left=of 6] (06) {};
	\node[right=of 11] (21) {};
	\node[right=of 16] (26) {};

	\path[-]
	(1) edge  node  {} (13)
		edge [CoralRed, line width=2pt] node {} (2)
	(2) edge [CoralRed, line width=2pt] node {} (3)
	(3) edge node {} (4)
		edge [CoralRed, line width=2pt] node {} (11)
	(4) edge [CoralRed, line width=2pt]node {} (16)
    	edge [CoralRed, line width=2pt] node {} (5)
	(5) edge [CoralRed, line width=2pt] node {}(6)
	(6) edge node {}(14)
	(11) edge [CoralRed, line width=2pt] node {}(12)
    (12) edge [CoralRed, line width=2pt]node {}(13)
	(13) edge [CoralRed, line width=2pt]node {}(14)
	(14) edge [CoralRed, line width=2pt]node {}(15)
	(15) edge [CoralRed, line width=2pt]node {} (16)
	(01) edge [CoralRed, line width=2pt]node {} (1)
	(06) edge [CoralRed, line width=2pt] node {} (6)
	(21) edge node {} (11)
	(26) edge node {} (16);
  \end{tikzpicture}
  \end{center}

  Man kan dog også gøre det ved at komme ind fra den ene side, tage den, og så den anden side bagefter:

  \begin{center}
  \begin{tikzpicture}[node distance=1.5cm]

	\node[state] (1) {};
	\node[state, below=of 1]  (2) {};
	\node[state, below=of 2]  (3) {};
	\node[state, below=of 3]  (4) {};
	\node[state, below=of 4]  (5) {};
	\node[state, below=of 5]  (6) {};

	\node[state, right=of 1] (11) {};
	\node[state, below=of 11] (12) {};
	\node[state, below=of 12] (13) {};
	\node[state, below=of 13] (14) {};
	\node[state, below=of 14] (15) {};
	\node[state, below=of 15] (16) {};
	\node[left=of 1] (01) {};
	\node[left=of 6] (06) {};
	\node[right=of 11] (21) {};
	\node[right=of 16] (26) {};

	\path[-]
	(1) edge node {} (13)
		edge [TurquoiseGreen, line width=2pt]node {} (2)
	(2) edge [TurquoiseGreen, line width=2pt]node {} (3)
	(3) edge [TurquoiseGreen, line width=2pt]node {} (4)
		edge node {} (11)
	(4) edge node {} (16)
    	edge [TurquoiseGreen, line width=2pt]node {} (5)
	(5) edge [TurquoiseGreen, line width=2pt]node {}(6)
	(6) edge node {}(14)
	(11) edge [DeepSeaBlue, line width=2pt] node {}(12)
    (12) edge [DeepSeaBlue, line width=2pt]node {}(13)
	(13) edge [DeepSeaBlue, line width=2pt]node {}(14)
	(14) edge [DeepSeaBlue, line width=2pt]node {}(15)
	(15) edge [DeepSeaBlue, line width=2pt]node {} (16)
	(01) edge [TurquoiseGreen, line width=2pt] node {} (1)
	(06) edge [TurquoiseGreen, line width=2pt] node {} (6)
	(21) edge [DeepSeaBlue, line width=2pt]node {} (11)
	(26) edge [DeepSeaBlue, line width=2pt]node {} (16);
  \end{tikzpicture}
  \end{center}

  Lad $\langle G,k \rangle $ være en instans af vertex-cover, hvor $G = (V,E)$. For hver kant $u,v \in E$ tag en kopi, $W_{uv}$ af $W$, hvor $W$ er vores gadget vi lige har set to måder at tage hver knude i en cyklus på. Dermed, hvis der er 100 kanter har vi 100 kopier af $W$. Fiks så en ordning af naboerne om hver knude $u \in V$. Dette betyder simpelt, at for hver knude kan vi tænke på hver af knudens naboer som den 1. nabo, den 2. nabo etc. Så hver nabo til knuden $u \in V$ har en ``rangering'' af en art.

  %% MANGLER
  %% ærligt, læs i bogen i stedet, jørgens forklaringe r lidt for kludret
\end{proof}

\subsection{Cook-Levin Teoremet}%
\label{subsec:cooklevin}

%%% MANGLER: Heldigv is ikke så slemt som jeg havde regnet med.






%%% Local Variables:
%%% mode: latex
%%% TeX-engine: xetex
%%% TeX-command-extra-options: "-shell-escape"
%%% TeX-master: "main"
%%% End:
