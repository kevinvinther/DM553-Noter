\chapter{Church-Turing Tese}

De maskiner vi har kigget på indtil videre har enten været med endelig hukommelse (Endelige Automater) eller med en uendelig hukommelse der kun fungerer i en LIFO stak-hukommelse (PDA). Dermed er de for begrænset til at kunne agere som modeller af almene computere, da disse har ubegrænset, uendelig hukommelse.

\section{Turingmaskiner}%
\label{sec:turingmachines}

I 1936 introducerede Alan Turing \textit{turingmaskinen}, en deterministisk model som minder om en endelig automat, men med uendeligt og ubegrænset hukommelse. Denne model af en maskine kan alt det som en almen computer\footnote{Her bruges ``almen computer'' som en oversættelse fra det engelske ``General Purpose Computer''} kan gøre. Dermed kan vi bruge denne model til at finde ud af begrænsninger m.m. om de computere vi bruger i dagligdagen.

En turingmaskine bruger et uendeligt bånd som dets hukommelse. Den har en \textit{båndhoved} som kan læse \textit{og skrive} symboler og flytte sig selv rundt på båndet. Til at starte med indeholder båndet kan input strengen, dog kan den skrive på dette bånd. Til at læse informationen går båndhovedet over de symboler der skal læses. Maskinen bliver ved med at komputere indtil den vælger at producere et output, enten \textit{accept} eller \textit{afvis}. Hvis den ikke kommer til et accept eller afvis state, så kører den for evigt, uden nogensinde at stoppe. Når komputeringen rammer en af disse states, stopper komputeringen.

\begin{figure}[ht]
	\centering
	\begin{tikzpicture}
		\tikzset{block/.style={rectangle, draw, minimum height=2em, minimum width=3em}}
		\tikzset{line/.style={draw, -latex'}}
		\node[block] (control) {control};

		\node[block, minimum width=0.8cm] (a1) at (2,-1.0) {a};
		\node[block, minimum width=0.8cm] (a2) at (2.8,-1.0) {a};
		\node[block, minimum width=0.8cm] (b1) at (3.6,-1.0) {b};
		\node[block, minimum width=0.8cm] (b2) at (4.4,-1.0) {b};
		\node[block, minimum width=0.8cm] (b2) at (5.2,-1.0) {$\sqcup$};
		\node[block, minimum width=0.8cm] (b2) at (6.0,-1.0) {$\sqcup$};
		\node[block, minimum width=0.8cm] (b2) at (6.8,-1.0) {$\sqcup$};
		\node[label, minimum width=0.8cm] (b2) at (7.6,-1.0) {$\cdots$};

		\draw[->, thick] (control) -| (a1);
	\end{tikzpicture}
	\caption{\label{fig:turingschematic} Skematik af en turingmaskine.}
\end{figure}
I Figur~\ref{fig:turingschematic} kan der ses en skematik på en turingmaskine. Læg her mærke til at båndet er uendeligt langt, og efter input strengen er der bare blanke symboler, her betegnet som $\sqcup$.

Følgende punkter opsummerer forskellen mellem en endelig automat og en turingmaskine:

\begin{enumerate}
	\item En Turingmaskine kan både læse og skrive fra båndet.
	\item Læs-skriv (read-write) hovedet kan bevæge sig både til athøjre og til venstre.
	\item Båndet er uendeligt.
	\item De speceielle states til at acceptere og afvise et input træder i kraft med det samme.
\end{enumerate}



\subsection{Formel Definition af en Turingmaskine}%
\label{subsec:formaldefturingmachine}



Trods vi næsten aldrig bruger den formelle beskrivelse af en turingmaskine, da de oftest ender med at blive alt for store, giver vi den generelle formelle beskrivelse af en turingmaskine her.

Transitionsfunktionen i en turing maskine har formen $Q \times \Gamma \longrightarrow Q \times \Gamma \times \{L, R\}$. For eksempel betyder $\delta (q,a) = (r,b,L)$ at når båndet er over symbol $a$ og maskinen er i state $q$, så skal den skrive $b$ til symbolet hvor $a$ tidligere stod, og gå til state $r$. $L$ betyder her at den skal bevæge sig til venstre.

\begin{definition}[Formel Definition af en Turingmaskine]
	\label{def:formalturing}
	En \textbf{Turingmaskine} er en 7-tuple $(Q, \Sigma, \Gamma, \delta, q_{0}, q_{\text{accept}}, q_{\text{reject}})$, hvor $Q, \Sigma, \Gamma$ alle er endelige sæt, og
	\begin{enumerate}
		\item $Q$ er sættet af states.
		\item $\Sigma$ er inputalfabetet ikke indeholdende det blanke symbol, $\sqcup$.
		\item $\Gamma$ er båndalfabetet, hvor $\sqcup \in \Gamma$ og $\Sigma \subseteq \Gamma$.
		\item $\delta, Q \times \Gamma \longrightarrow Q \times \Gamma \times \{L, R\}$ er transitionsfunktionen.
		\item $q_{0} \in Q$ er startstaten.
		\item $q_{\text{accept}} \in Q$ er accept staten.
		\item $q_{\text{reject}} \in Q$ er afvis staten, hvor $q_{\text{accept}} \neq q_{\text{reject}}$.
	\end{enumerate}
\end{definition}

Bemærk at, på trods af at Sipser ikke skriver det som en mulighed, kan man nemt implementere ``stay'' (her skrevet S) som en mulighed, fromfor kun at vælge left eller right. Du kan gøre dette ved at først skrive, så gå til højre, så gå til venstre uden at gøre noget med symbolet.


\subsection{Turingmaskine Komputering}%
\label{subsec:turingmaskinekomputering}

En turingmaskine komputere ved at starte sit båndhoved på den venstremest symbol på båndet. Inputtet $w = w_{1}w_{2} \ldots w_{n} \in \Sigma^{*}$ er på de første (venstremest) $n$ pladser på båndet, og det resterende er blankt. Siden $\Sigma$ ikke indeholder de blanke symbol, kan man være sikker på at så snart det blanke symbol kommer på båndet, har man læst inputtet færdigt. Hvis hovedet nogensinde forsøger at bevæge sig mere til venstre end muligt, så forbliver hovedet på den venstremest symbolplacering, trods den ``skal'' gå til venstre. Når $M$ er begyndt bevæger den sig efter reglerne beskrevet i transitionsfunktionen, indtil den enten accepterer eller afviser inputtet og dermed stopper. Hvis den hverken accepterer eller afviser inputtet kører den forevigt.


I Figur~\ref{fig:turingcomputation} ses hvordan båndindholdet, hovedet, og staten ændrer sig fra en state til en anden, givet reglen $\delta(q_{i}, c) = (q_{j}, x, L)$.

\begin{figure}[ht]
	\centering
	\begin{tikzpicture}
		\tikzset{block/.style={rectangle, draw}}
		\tikzset{line/.style={draw, -latex'}}

		% Define starting position
		\def\startx{0}
		\def\gap{0.8} % Gap between each block


		\node[draw=none, fill=none] at (-1.4, -0.2) { \begin{tabular}{c}Venstre $\rightarrow$\\Ende\end{tabular} };
		% Labels for each block, can add/remove as needed
		\def\labels{a, a, a, b, b, b, c, $\sqcup$, $\ldots$, $\sqcup$}

		% Foreach loop to create nodes automatically
		\foreach \label [count=\i] in \labels {
			\node[block, minimum width=0.8cm, minimum height=0.8cm] (block\i) at (\startx + \gap*\i - \gap,0.0) {\label};
		}

		\node[block, minimum width=1.0cm, minimum height=1.0cm, draw=SchemeRed, line width=0.40mm] (reading) at (2.4, 0.0) {};
		\node[draw=none, fill=none, text=SchemeRed] at (2.4, -0.7) { Hovedet };
		\node[draw=none, fill=none] at (8.0, 0.0) {$\rightarrow \infty$};
		\node[draw=none, fill=none, text=SchemeBlue] at (5.4, -0.7) { State $q_{i}$ };
		\node[draw=none, fill=none] at (5.4, -1.7) { $\Downarrow$ \hspace{1cm} $\delta(q_{i},c) = (q_{j}, x, L)$ };


		\def\labelstwo{a, a, a, x, b, b, c, $\sqcup$, $\ldots$, $\sqcup$}

		% Foreach loop to create nodes automatically
		\foreach \label [count=\y] in \labelstwo {
			\node[block, minimum width=0.8cm, minimum height=0.8cm] (block\y) at (\startx + \gap*\y - \gap,-3.0) {\label};
		}
		\node[block, minimum width=1.0cm, minimum height=1.0cm, draw=SchemeRed, line width=0.40mm] (reading) at (1.6, -3.0) {};
		\node[draw=none, fill=none, text=SchemeRed] at (1.6, -3.7) { Hovedet };
		\node[draw=none, fill=none] at (8.0, -3.0) {$\rightarrow \infty$};
		\node[draw=none, fill=none, text=SchemeBlue] at (5.4, -3.7) { State $q_{j}$ };
	\end{tikzpicture}
	\caption{\label{fig:turingcomputation} Komputering i en Turingmaskine.}
\end{figure}

En \textit{konfiguration} er en kombination af de følgende tre ting:
\begin{itemize}
	\item Den nuværende state.
	\item Det nuværende indhold af båndet.
	\item Hovedet nuværende lokation.
\end{itemize}

De her konfigurationer bliver oftest repræsenteret på følgende måde: Givet en state $q$ og to strenge $u$ og $v$ over båndalfabetet $\Gamma$, skriver vi $uqv$ for konfigurationen hvor den nuværende state er $q$, båndindholdet er $uv$ og hovedets lokation er ved det andet symbol, altså $v$.

Vi siger at en konfiguration $C_{1}$ \textit{giver} konfigurationen $C_{2}$ hvis turingmaskinen lovligt kan gå fra $C_{1}$ til $C_{2}$ på et enkelt skridt.

\textit{Startkonfigurationen} af $M$ på input $w$ er konfigurationen $q_{0}w$. Altså hvor staten er helt i start, og resterende af strengen, $w$ efterfølger. I en \textit{accepterende konfiguration} er staten i en konfiguration $q_{\text{accept}}$. I en \textit{afvisende konfiguration} er staten $q_{\text{reject}}$. Accept og afvisekonfigurationer er \textit{standsende konfigurationer}, altså konfigurationer som ikke giver flere konfigurationer.

Vi kalder samlingen af strenge som $M$ accepterer \textit{sproget af $M$} eller \textit{sproget genkendt af $M$}, betegnet $L(M)$.

\begin{definition}
	Kald et sprog \textit{Turing-genkendeligt} hvis en Turingmaskine genkender det.
\end{definition}

Dette kan også beskrives $L(m) = \{w \mid q_{0}w \stackrel{*}{\Rightarrow} uq_{\text{acc}}v \text{ for nogen }u,v \in \Gamma^{*}\}$

Når en turingmaskine startes er tre resultater mulige, enten vil maskinen \textit{acceptere}, \textit{afvise} eller \textit{løkke}\footnote{\textit{loop} på engelsk}, hvor \textit{løkke} betyder at maskinen vil køre forevigt.


Vi kalder maskiner der aldrig kommer i en løkke for beslutningstagere eller afgørerere\footnote{Måske? Deciders på engelsk.}, fordi de altid afgører hvorvidt en streng skal accepteres eller afvises. En afgører som genkender et sprog, siges også at \textit{afgøre} det sprog.

\begin{definition}
	Kald et sprog Turing-afgjort eller simpelt afgjort, hvis en turingmaskine afgører (beslutter) det.
\end{definition}

Dette kaldes også \textit{rekursivt enumerabelt\footnote{Engelsk: recursively enumerable}} i litteraturen.

\begin{figure}[ht]
	\centering
	\begin{tikzpicture}
		\draw[SchemeLight,fill=SchemeLight,dashed, thick, opacity=0.2] (0.5,0) ellipse (4cm and 2cm);
		\draw node at (1.7,1) {Genkendelige sprog};
		\draw[SchemeBlue,fill=SchemeBlue,dashed, thick, opacity=0.5] (-1.0,0) ellipse (2cm and 1.0cm);
		\draw node at (-1,0) {Afgørlige sprog};
	\end{tikzpicture}
	\caption{\label{fig:univers} Univers af sprog}
\end{figure}

I figur~\ref{fig:univers} ses der hvordan de afgørlige sprog kun er en delmængde af alle de genkendelige sprog. Under de afgørlige sprog ligger også kontekstfrie sprog og regulære sprog.

\section{Varianter af Turingmaskiner}%
\label{sec:turingvariants}

Vi kalder andre versioner af turingmaskinen, herunder maskiner med flere bånd eller nondeterministiske maskiner for \textit{varianter}. Den originale model og alle dens varianter har samme deskriptive kraft. Vi kalder dette \textit{robusthed}, altså, at maskinerne alle beskriver samme klasse af sprog.

\subsection{Multibånds Turingmaskiner}%
\label{subsec:multitape}

En \textbf{multibånds turingmaskine} er som en normal turingmaskine, men med mere end ét bånd (hvor antallet \textbf{ikke} må ændres under kørsel.) Transitionsfunktionen ændres så den kan køre på mere end ét bånd:
\[ \delta : Q \times \Gamma^{k} \longrightarrow Q \times \Gamma^{k} \times \{L,R,S\}^{k}\] hvor $k$ er antallet af states. Dermed fungerer transitionsfunktionen ved at tage den nuværende state i alle tapes og giver resultatet i alle states, eksempelvis: $\delta(q_{i}, a_{1}, \ldots, a_{k}) = (q_{j}, b_{1}, \ldots, b_{k}, L, R, \ldots, L)$, hvor $b_{i}$ erstatter $a_{i}$, når hovedet bevæges. Jørgens implementation af multibåndsmaskinen har også $\gamma_{j} \in \{L, R, S\}$, altså, hvor han tillader hovedet at stå stille.

En multibånds turingmaskine kan være meget brugbar, ved at gøre ting mere intuitivt nemme at forstå (på samme måde som en NFA.) Et godt eksempel på dette er kopiering af en streng. Følgende algoritme vil fungere til \textbf{alle} $k-$bånds turingmaskiner, hvor $k \ge 2$. Lad $m$ være maskinen, der kopierer sit input $w$.

Lad $m$ på input $w$:
\begin{enumerate}
	\item For hvert bogstav i bånd 1, kopiér dette ned til bånd 2.
	\item Flyt hovedet i bånd 1 til første tomme symbol, $\sqcup$.
	\item Kopiér fra bånd 2 symbol-pr-symbol til bånd 1, start ved hovedets lokation.
	\item Fjern indhold i bånd 1.
\end{enumerate}

Dette kan gøres i $O(|w|)$ skridt, imens den kan gøres i $O(|w|^{2})$ skridt i en 1-båndsmaskine. Altså er det en væsentlig hurtigere måde at gøre det på, men begge kører alligevel i polynomiel tid.


\begin{theorem}
	\label{teo:multitapeequiv}
	Hver multibånds turingmaskine har en ækvivalent enkeltbånds turingmaskine.
\end{theorem}

\begin{proof}
	For at bevise dette, skal vi vise at enhver multibånds Turingmaskine $M$ kan konverteres til en enkeltbånds Turingmaskine $S$. Vi siger at $M$ har $k$ bånd. Så bruger $S$ symbolet \# til at indikere at et nyt bånd starter. Derudover skal $S$ også holde styr på lokationen af hovederne fra diverse bånd. Den gør dette ved at skrive en bolle over symbolet: $\mathring{b}$.

	Så en maskine med tre bånd som f.eks.:\\
	\begin{center}
		\noindent
		\texttt{\textbf{a}aaaabababbb}\\
		\noindent
		\texttt{bbbbb\textbf{b}bbbbba}\\
		\noindent
		\texttt{a\textbf{b}aaababbaba}\\
	\end{center}
	Hvor \textbf{tyk skrift} indikerer hovedets placering, bliver lavet om til i $S$:
	\begin{center}
		\texttt{$\stackrel{\circ}{\text{\texttt{a}}}$aaaabababbb\#bbbbb$\stackrel{\circ}{\text{\texttt{b}}}$bbbbba\#a$\stackrel{\circ}{\text{\texttt{b}}}$aaababbaba\#}.
	  \end{center}

	Vi definerer nu $S$.

	$S = $ ``På input $w = w_{1} \cdots w_{n}$'':
	\begin{enumerate}
		\item Først konverterer $S$ til enkeltbånd.
		\item Til at simulere en enkelt bevægelse, scanner $S$ fra den første \# til $k+1$'e \#, som er slutningen i højresiden, så den kan finde ud af hvad symbolerne under de virtuelle hoveder er. Så laver $S$ en til passthrough til at opdatere ifølge reglerne. Hvis på noget tidpsunkt, $S$ vil flytte til højre til et $\#$ (altså, hvad der i det originale bånd er $\sqcup$), så rightshifter $S$ alt derfra, så vi får ekstra plads, til hvor der ville være et blankt symbol. På samme måde kan vi leftshifte, hvis det er en nødvendighed.
	\end{enumerate}

	Altså vil alle symboler med en bolle over agere som hovederne på et normalt bånd, hvor hovedet så simulerer hvad reglerne er for hver af båndene.
\end{proof}

Vi kan i beviset tydeligt se hvordan det kan gøres, men hvordan kan en simulerende Turingmaskine som $S$ huske at den har set de tidligere hoveder? Følgende er en beskrivelse af en algoritme der kan konvertere enhver $k-$bånds Turingmaskine til en $1-$bånds Turingmkasine.

\begin{enumerate}
  \item Antag at $M$ er en $k-$bånds Turingmaskine.
  \item For hver state $q_{i}$ i $M$ har vi:
		\begin{enumerate}
		  \item\label{enum:ktapealgo:qi} States $q^{i}_{(\alpha_{1}, \alpha_{2}, \ldots, \alpha_{k})}$ når $a_{i} \in \Gamma \cup \{-\}$, hvor $-$ betyder tomme eller endnu ikke kendt, altså, vi ved endnu ikke hvad der skal være der.
		  \item\label{enum:ktapealgo:pi} States $p^{i}_{(\delta_{1}, \delta_{2}, \ldots, \delta_{k}, b_{1}, b_{2}, \ldots, b_{k}, \gamma_{1}, \gamma_{2}, \ldots, \gamma_{k})}$ hvor $\delta_{i} \in \Gamma \cup \{-\}$, $b_{i} \in \Gamma$, $\gamma_{i} \in \{R, L, S\}$. Så altså, det første (\(\delta\)) er enten båndsymboler eller ukendt, $b$  er båndsymboler,  og $\gamma$ er hovedbevægelser.
		\end{enumerate}
\end{enumerate}

For at forklare dybere: \ref{enum:ktapealgo:qi}: Når vi er i $q^{i}_{(\beta_{1}, \beta_{2}, \ldots, \beta_{r},-,-,\ldots,-)}$ har vi indsamlet alle symbolerne under hovederne på de første $r$ bånd. Her betyder symbolerne $-$ igen at det er symboler som vi ikke kender endnu. Altså betyder det at \(\beta_{k}\) har hvad det simulerer bånd nummer $k$'s symbol under hovedet.
\ref{enum:ktapealgo:pi}: Når vi er i $p^{i}_{(b_{1}, \ldots, b_{q}, -, \ldots, -, b_{1}, b_{2}, \ldots, b_k, \gamma_{1}, \gamma_{2}, \ldots, \gamma_{k})}$ har vi ændret båndcellerne under de første $q$ hoevbder og flyttet den $i'$e hoved $i \le q$ ifølge $\gamma_{i}$ og muligvis rightshifted. Altså, når vi er i den state, har vi allerede erstattet $a_{1}, \ldots, a_{q}$ med $b_{1}, \ldots, b_{q}$ og vi har flyttet hovederne ifølge reglerne $\delta_{1}, \ldots \delta_{k}$.

Vi kan her se at der  er mange af de mulige states beskrevet i \ref{enum:ktapealgo:pi} og \ref{enum:ktapealgo:qi}. Til $q^{i}$ er der $(\Gamma+1)^{k}$ (fordi der er $k$ states, og $\Gamma$ symboler eksklusiv $-$). Til $p^{i}$ er det $(\Gamma+1)^{k} + \Gamma^{k} + 3^{k}$. Altså er der utroligt mange mulige states.

Altså kan man se det totale antal af states som en \textbf{endelig} funktion $f(k, \Gamma, Q)$. Altså er antallet af states polynomielt, og \textbf{ikke} eksponentielt, da $k$ er en konstant.

Lad os nu implementere ét skridt $\delta(q_{i}, a_{1}, a_{2}, \ldots, a_{n}) = (q_{j}, b_{1}, b_{2}, \ldots, b_{k}, \gamma_{1}, \gamma_{2}, \ldots, \gamma_{k})$.
\begin{enumerate}
  \item $M'$ starter i state $q^{i}_{(-,-, \ldots, -)}$ på den venstremest position altså uden kendskab til nogen symboler.
  \item I state $q^{i}(a_{1}, \ldots, a_{r}, -, \ldots, -)$ $r < k$, flytter $m'$ dets hoved fremad til at kopiere indholdet under $m'$s $(r+1)$'e hoved. Vi husker så via. staten, altså, når vi har set symbol $a$ under det $i$'e hoved, så går vi til den state der har symbol $a$ under det $i$'e hoved. Det er måden vores hukommelse fungerer på.
  \item Når vi når til state $q^{i}_{(a_{1}, a_{2}, \ldots, a_{k})}$ $\beta_{i} \in \Gamma$ har vi samlet alle karakterer under $m'$s hoveder. Så er det tid til at ændre på disse symboler. Jævnfør algoritmen vi har set tidligere gør vi dette ved hjælp af en ``mellem-state'', $p^{j}$ (hvor vi egentlig gerne vil hen til $q_{j}$.) Vi går til state $p^{j}_{(-, \ldots, -, b_{1}, b_{2}, \ldots, b_{k}, \gamma_{1}, \gamma_{2}, \ldots, \gamma_{k})}$ hvor vi endnu ikke ved hvad de første symboler der skal ændres er, men vi ved hvad de skal ændres \textit{til} (fra transitionsfunktionens definition skrevet lige før starten på denne implementation.)
  \item I state $p^{j}_{(b_{1}, \ldots, b_{s}, -, \ldots, -, b_{1}, b_{2}, \ldots, b_{k}, \gamma_{1}, \gamma_{2}, \ldots, \gamma_{k})}$ hvor $s < k$ gør vi følgende:
		\begin{enumerate}
		  \item Flytter til positionen af det $(s+1)$'e hoved.
		  \item Erstatter $a_{s+1}$ med $b_{s+1}$ og flytter ``hovedet'' $s+1$ ifølge $\gamma_{s+1}$
		  \item Hvis $s+1<k$ går vi til state $p^{j}_{(b_{1}, \ldots, b_{s+1}, \cdots, b_{1}, b_{2}, \ldots, b_{k}, \gamma_{1}, \ldots, \gamma_{k})}$, og tager skridt 4 om igen. \textbf{Ellers} flytter vi hovedet til den venstremest position og går til state $q^{j}_{(-, \ldots, -)}$
		\end{enumerate}
\end{enumerate}

Hvad er \textbf{køretiden} så for denne simulation? Givet en afgørlig Turingmaskine (altså, der stopper), som tager $t$ skridt på input $w, |w| = n$. Båndet i denne Turingmaskine kan have højest længde $n + t$, da den starter med input $n$, og højest kan lave $t$ ændringer til båndet der gør den længere. Lad os forsøge at ræssonere os frem til køretiden. Vi kører frem og tilbage i båndet flere gange, for hvert skridt kører vi frem én gang, så kører vi tilbage, og så kører vi frem (hvor vi udfører transitionsfunktionen); og så tilbage. Altså gør vi det fire gange. Dermed har ét skridt køretid $O(\Sigma \text{ længden af båndet}) = O(n+kt)$, hvor $k$ er antal bånd. Derudover er det muligt, at vi skal lave flere \textit{rightshifts}. I worst case scenariet shifter vi hver gang, hvilket giver os $(k-1)t + (k-2)t + \cdots + t = O(k^{2}t)$. Dermed er det samlede arbejde gjort på ét skidt $O(n+kt)+O(k^{2}t) = O(n+k^{2}t)$. Da vi har $t$ skridt, vil det samlede arbejde for at simulere disse skridt være $O(n \cdot t + k^{2}t^{2})$, hvilket er polynomielt i $n$ og $t$.




\begin{corollary}
	Et sprog er Turing-genkendeligt hvis og kun hvis en multibånds Turingmaskine genkender det.
\end{corollary}

\begin{proof}
	En Turingmaskine er genkendt af en multibåndsmaskine med ét bånd. Den anden vej bevises i Teorem~\ref{teo:multitapeequiv}.
\end{proof}


\subsection{2-vejs bånd}
\label{subsec:2vejsbånd}

Denne variant minder om en normal, deterministisk turingmaskine. Dog har den en ekstra egenskab: nemlig at den også er uendelig på venstresiden. I Figur~\ref{fig:2vejsbånd} ses en skitse af hvordan en 2-vejs bånds Turingmaskine ser ud.

\begin{figure}[ht]
	\centering
	\begin{tikzpicture}
		\tikzset{block/.style={rectangle, draw}}
		\tikzset{line/.style={draw, -latex'}}

		% Define starting position
		\def\startx{0}
		\def\gap{0.8} % Gap between each block


		% Labels for each block, can add/remove as needed
		\def\labels{ ,  ,  ,  ,  ,  ,  , , }
		\def\indices{-4,-3,-2,-1,0,1,2,3,4}

		% Foreach loop to create nodes automatically
		\foreach \label [count=\i] in \labels {
			\node[block, minimum width=0.8cm, minimum height=0.8cm] (block\i) at (\startx + \gap*\i - \gap,0.0) {\label};
		}
		\foreach \label [count=\y] in \indices {
			\node[draw=none, fill=none, minimum width=0.8cm, minimum height=0.8cm,color=SchemeRed] (block\y) at (\startx + \gap*\y - \gap,0.7) {\label};
		}

		\node[draw=none, fill=none] at (7.2, 0.0) {$\rightarrow \infty$};
		\node[draw=none, fill=none] at (-0.8, 0.0) {$\infty \leftarrow$};

	\end{tikzpicture}
	\caption{\label{fig:2vejsbånd} 2-vejs bånd variant.}
\end{figure}


\subsection{Nondeterministisk Turingmaskine}%
\label{subsec:nondeterministicturingmachine}

En nondeterministisk turingmaskine fungerer nondeterministisk ligesom PDA og NFA. Altså kan den gætte fra et state $q$, hvad den skal gøre som det næste. Dette betyder også at der er $B = |Q| \cdot |\Gamma| \cdot 3$ mulige transitioner.
Den brancher ud for hver mulighed. Transitionsfunktionen beskrives således:
\[ \delta : Q \times \Gamma \longrightarrow P(Q \times \Gamma \times \{L, R, S\})\]\footnote{Sipser bruger ikke $S$ som mulighed for at bevæge sig.}
Man kan se komputeringen som en træ-struktur, hvor hver gang den gætter, kommer der en ny gren på. Hvis en af de her grene ender i en accept state, så accepteres inputtet. Det er vigtigt at bemærke at hver transition, $\delta(q,a)$ har et endeligt antal, $B$, af mulige transitions, da $B \le |Q| \cdot |\Gamma| \cdot 3$.

Vi kalder en nondeterministisk turingmaskine en \textbf{afgører} hvis den stopper på alle grene.

Hvordan kan dette så være brugbart? For eksempel kan en nondeterministisk turingmaskine nemt finde ud af om $n$ er et sammensat tal (altså, ikke et primtal.) Den gør dette ved at have et heltal $n > 1$, og så gætter på alle tal om $m = n_{1} \cdot n_{2}$, ved at udregne deres værdi, og sætte lighed mellem denne og $n$.


\begin{definition}
  \label{def:ndtmrecog}
En nondeterministisk Turingmaskine (NDTM) $m$ \textbf{genkender} $L$ hvis $L = \{w \mid \exists \text{ en komputering for }M \text{ på } w \text{ der leder til } M \text{'s accept state} \}$
\end{definition}

\begin{definition}
  \label{def:ndtmdecide}
  En nondeterministik Turingmaskine $m$ \textbf{afgører} $L$ hvis $\forall w \in \Sigma^{*}$:
  \begin{enumerate}
	\item $\exists k = k(m,w)$ således at $m$ aldrig tagere mere end $k$ skridt på $w$, altså alle længder i træet har længde $\leq k$.
	\item $w \in L \iff m$  har mindst én accepterende beregning på $w$. Altså betyder det ikke at $w$ skal accepteres, men at hvis den accepteres, er den i sproget, og omvendt.
  \end{enumerate}
\end{definition}

Forskellen på Definitionerne \ref{def:ndtmrecog} og \ref{def:ndtmdecide} er at en Turingmaskine der genkender \textbf{tillader} uendelige veje, så længe der er en accept state, hvor en afgørende Turingmaskine \textbf{ikke} tillader uendelige veje.

\begin{theorem}
	\label{teo:nondeterminismturingequiv}
	Hver nondeterministisk turingmaskine har en ækvivalent deterministisk Turingmaskine.
\end{theorem}

Givet en deterministisk Turingmaskine $D$ der er ækvivalent til den nondeterministiske Turingmaskine $N$ gælder det at $L(D) = L(M)$ og $D$ afgører $L \iff N$ afgører $L$.

Vi vil gerne bevise ved at have en deterministisk turingmaskine $D$ til at simulere alle grene der er mulige v.h.a. nondeterminisme. Vi designer $D$ til at bruge breadth-first-search til at kigge alle grene igennem.

Vi vil gerne bruge \textit{breadth-first search} til at simulere $N$ på $w$. Vi ved at dette er muligt, fordi der ved hver state er \textbf{højest} $B$ transitions. Til gengæld vil vi ikke kunne gøre det med depth-first, da uendelige veje er mulige i træet.

Vi antager her at hver transition, $\delta(q,a)$ har \textbf{præcis} $B$ transitioner, eller ingen. Vi kan klare dette ved at kopiere den sidste state det antal gange der skal til, for at antallet af transitions bliver til $B$; e.g, hvis $B = 4$, og $\delta(q,a) = \{(q, b, R)\}$ så ændrer vi den til at være $\delta(q,a) = \{(q,b,R),(q,b,R),(q,b,R),(q,b,R)\}$

For en given streng $g_{1}g_{2}\cdots g_{k}$ hvor $g_{i} \in \{1, 2, \ldots, B\}$ kan vi simulere den korresponderende komputering af $N$  ved at tage det $g_{i}$'e valg på skridt $i$. Altså er en mulig streng 274, hvilket betyder at vi i første skridt tager valg nummer 2, i det andet valg nummer 7, og i det tredje valg nummer 4 (her er $B \ge 7$, da 7 er det største tal i strengen.) Hvis vi kan implementere simulationen beskrevet her ved en deterministisk Turingmaskine $D$, så opfylder $D$ Teorem~\ref{teo:nondeterminismturingequiv}.

Måden vi kigger komputeringerne igennem på er ved at gå lexicografisk igennem dem. Altså starter vi med alle strenge af længde én, og derefter længde to etc. Vi kører igennem de ``første'' tal først, så altså først 123, så 124, så 149 etc. Vi bliver ved med at gøre det på denne måde indtil vi finder en accepterende konfiguration.

Vi kan holde styr på tallene ved at bruge båndet i turingmaskinen. For eksempel kan strengen 223 blive repræsenteret således:
\begin{center}
\texttt{\#00\#00\#000\#}
\end{center}
Hvor den første del har to 0'er, den anden del har også to 0'er, og den tredje har tre 0'er.

Lad os nu kigge på hvordan vi faktisk laver den deterministiske Turingmaskine $D$ som simulerer $N$.
$D$ vil have 3 bånd:
\begin{enumerate}
  \item Input.
  \item $N$'s udregninger på $w$.
  \item Tal base $B+1$.
\end{enumerate}

For eksempel:
\begin{enumerate}
  \item $w_{1}w_{2} \cdots w_{n}$
  \item Simulering i 3 skridt i henhold til skridt 3.
  \item 235
\end{enumerate}

Hvis vi når til en komputering der ikke eksisterer (da vi går dem alle igennem), så stopper vi udregningen og går videre til næste mulighed.
Bemærk her at hvis $N$ er i en accepting state, så vil $D$ også acceptere input. På samme måde, hvis $N$ er en afgører, og $D$ har været \textbf{alle} states igennem, og endnu ikke fundet et accepting state, så bliver input afvist.

Lad os formalisere, og dermed færdiggøre beviset til Teorem~\ref{teo:nondeterminismturingequiv}:

\begin{proof}
\begin{enumerate}
  \item \begin{enumerate}
		  \item $w_{1}w_{2}\cdots w_{n}$
		  \item $\sqcup$
		  \item $\#0\#$
		\end{enumerate}
  \item Kopiér bånd 1 til bånd 2
  \item Simulér $N$ på bånd 2 ved brug af tallene på bånd 3 til at vælge den næste transition indtil følgende sker:
		\begin{itemize}
		  \item Dead end
		  \item $M$ accepteres, så vil $D$ også acceptere og stoppe udregning
		  \item $M$ afviser
		  \item Der ikke er flere tal på bånd 3
		\end{itemize}
  \item Erstat $d_{1},d_{2},\ldots, d_{r}$ på bånd 3 med det næste i leksikografisk orden
  \item Gå til skridt 2.
\end{enumerate}
\end{proof}


\begin{corollary}
	Et sprog er turing-genkendeligt hvis og kun hvis en nondeterministisk Turingmaskine genkender det.
\end{corollary}

\begin{proof}
	Enhver deterministisk Turingmaskine er automatisk også en nondeterministisk turingmaskine. Den anden retning følger fra~\ref{teo:nondeterminismturingequiv}.
\end{proof}

Hvor lang tid tager denne simulation af $N$ for $D$? Hvis vi antager at $N$ kører i $r$ skridt (altså, $r$ beregninger), så vil $D$ højest simulere
\begin{equation}
B+B^{2}+\cdots +B^{r} \leq B^{r+1}
\end{equation}
Altså vil den køre i \textbf{eksponentiel tid}. Dette kommer fra at der kan være $B$ udregninger i strengen af længde 1, $B^{2}$ af strengen af længde 2, etc\footnote{``Strengen'' her betyder den udregning vi er nået til, som brugt i bevisidéen til Teorem~\ref{teo:nondeterminismturingequiv}}.

\textbf{Hvis vi kunne lave en algoritme} der konverterer en nondeterministisk Turingmaskine til en deterministisk Turingmaskine som kører i polynomiel tid, ville vi bevise $P = NP$\footnote{Vi kommer ind på dette senere i kurset.}.

\subsection{Et bånd med flere hoveder}%
\label{subsec:etbåndflerehoveder}

\begin{figure}[ht]
	\centering
	\begin{tikzpicture}
		\tikzset{block/.style={rectangle, draw}}
		\tikzset{line/.style={draw, -latex'}}

		% Define starting position
		\def\startx{0}
		\def\gap{0.8} % Gap between each block


		% Labels for each block, can add/remove as needed
		\def\labels{ ,  ,  ,  ,  ,  ,  , , }

		% Foreach loop to create nodes automatically
		\foreach \label [count=\i] in \labels {
			\node[block, minimum width=0.8cm, minimum height=0.8cm] (block\i) at (\startx + \gap*\i - \gap,0.0) {\label};
		}

		\node[draw=none, fill=none] at (7.2, 0.0) {$\rightarrow \infty$};

		\node[block, minimum width=1.0cm, minimum height=1.2cm, draw=SchemeRed, line width=0.4mm] (h1) at (1.6, 0.0) {};
		\node[draw=none, fill=none, text=SchemeRed] (h1t) at (1.6, -1.0) {$h_{1}$};

		\node[block, minimum width=1.0cm, minimum height=1.2cm, draw=SchemeGreen, line width=0.4mm] (h1) at (3.2, 0.0) {};
		\node[draw=none, fill=none, text=SchemeGreen] (h1t) at (3.2, -1.0) {$h_{2}$};

		\node[block, minimum width=1.2cm, minimum height=2.0cm, draw=SchemeBlue, line width=0.4mm] (h1) at (3.2, -0.2) {};
		\node[draw=none, fill=none, text=SchemeBlue] (h1t) at (3.2, -1.5) {$h_{3}$};

		\node[block, minimum width=1.0cm, minimum height=1.2cm, draw=SchemeViolet, line width=0.4mm] (h1) at (4.8, 0.0) {};
		\node[draw=none, fill=none, text=SchemeViolet] (h1t) at (4.8, -1.0) {$h_{4}$};
	\end{tikzpicture}
	\caption{\label{fig:flerehoveder} Flerhovedet-bånd variant.}
\end{figure}

I figur~\ref{fig:flerehoveder} ses en tegning af hvordan en variant af turingmaskinen, hvor der er flere hoveder på et bånd ser ud. Til at starte med starter alle hoveder på samme lokation, til venstre. Denne variant er brugbar til problemer såsom at genkende sproget $L = \{a^{n}b^{n}c^{n} \mid n \ge 0\}$

\subsection{To-dimensionelt bånd}%
\label{subsec:todimensioneltbånd}

I denne variant af en turingmaskine, er der er to-dimensionelt bånd.

\begin{figure}[ht]
	\centering
	\begin{tikzpicture}
		\tikzset{block/.style={rectangle, draw}}
		\tikzset{line/.style={draw, -latex'}}

		% Define starting position
		\def\startx{0}
		\def\gap{0.8} % Gap between each block


		% Labels for each block, can add/remove as needed
		\def\labels{ ,  ,  ,  ,  ,  ,  , , }

		% Foreach loop to create nodes automatically
		\foreach \label [count=\i] in \labels {
			\foreach \label [count=\y] in \labels {
				\node[block, minimum width=0.8cm, minimum height=0.8cm] (block\i\i) at (\startx + \gap*\i - \gap, 0.0 - \gap * \y) {\label};
			}
		}

		\node[draw=none, fill=none] at (7.2, -3.6) {$\rightarrow \infty$};
		\node[draw=none, fill=none] at (3.6, 0.0) {$\uparrow \infty$};

		\node[block, minimum width=1.0cm, minimum height=1.2cm, draw=SchemeRed, line width=0.4mm] (h1) at (3.2, -3.2) {};
		\node[draw=none, fill=none, text=SchemeRed] (h1t) at (3.2, -4.2) {$h_{1}$};
	\end{tikzpicture}
	\caption{\label{fig:flerehoveder} Flerhovedet-bånd variant.}
\end{figure}






%%% Local Variables:
%%% mode: latex
%%% TeX-engine: xetex
%%% TeX-command-extra-options: "-shell-escape"
%%% TeX-master: "main"
%%% End:
